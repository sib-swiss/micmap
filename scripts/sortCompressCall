#!/bin/bash
#
# ------------------------------------------------------------------------------------------------------------------------
#
#                                * micmap *
#      Mapping of short reads in fastq format onto a reference
#
#
#  Copyright (C) SIB  - Swiss Institute of Bioinformatics,  2015-2019 Nicolas Guex, Thierry Schuepbach and Christian Iseli
#  Copyright (C) UNIL - University of Lausanne, Switzerland      2019 Nicolas Guex and Christian Iseli
#
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
#
#      Code:       Nicolas Guex, Thierry Schuepbach and Christian Iseli
#      Contacts:   Nicolas.Guex@unil.ch and Christian.Iseli@unil.ch
#      Repository: https://github.com/sib-swiss/micmap
#
# ------------------------------------------------------------------------------------------------------------------------
#
# Things to watch out for:
# - cpuspeed governor must be set to performance; if left to ondemand the kondemand threads kick in like crazy
#   look into /etc/sysconfig/cpuspeed and /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
#   GOVERNOR=performance
#   other options seems to be to disable cpuspeed module completely, but the performance setting seems to work fine
#   (if disabled, the /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor files do not exist)
# - if memory affinity is not set for GTLsimpleSort, it seems we navigate between nodes and the migration threads kick in like crazy
# - watchdog is better turned off; it tends to generate too many events when we get real busy
#   echo 0 > /proc/sys/kernel/nmi_watchdog
#   or set it up permanently in /etc/sysctl.conf : kernel.nmi_watchdog = 0
#
#./match_HOST -1 <(zcat /tmp/nodelete/mpeg/200x/${name}_1.fastq.gz) -2 <(zcat /tmp/nodelete/mpeg/200x/${name}_2.fastq.gz) -r /tmp/${name}
#    tromer=/scratch/ul/projects/chris/trome/human/chrom${c}_r.seq
BINDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
srcdir=/tmp
destdir=/tmp
tempdir=/tmp
tables=/data6
ref=b38
minPct=15
doSort=1
doCall=1
eraseInput=0
addWidth=0
minQualFilter="0"
minObsCount=4
doWiggle=0
# approximate ratio between original GTL file size and RAM used during sorting
ratio=23
alignconfig=""
threads=8
verbose=0
loop=0
lastFailure=0
UMI=0

function usage ()
{
  echo "Usage: $0 [options] name" >&2
  echo "" >&2
  echo "This script will take the output of micmap and sort/compress it in an output directory" >&2
  echo "It can also launch creation of a VCF file once the sorting is completed" >&2
  echo "" >&2
  echo "options (default values are given in square brackets):" >&2
  echo " -s <dir>    input directory, where the micmap output is located [$srcdir]" >&2
  echo " -d <dir>    output directory, where a new subdirectory named <name> will be created [$destdir]" >&2
  echo " -t <dir>    tables directory, where subdirectories for each reference is located [$tables]" >&2
  echo " -r <str>    name of the reference used for mapping [$ref - so files will be located in $tables/$ref]" >&2
  echo " -S          skip the sort step, useful to re-perform the calling step [default is to sort]" >&2
  echo " -C          skip the call step, useful to stop after the sorting step [default is to call]" >&2
  echo " -D          delete input gtl files after sorting and intermediate vcf files in case of annotation [default is to *not* erase]" >&2
  echo " -m <int>    minimum minor allele percent to make heterozygous call [$minPct]" >&2
  echo " -b <file>   bed-file containing selected regions to compute coverage [none]" >&2
  echo " -w <int>    augment selected regions (-b parameter) 5' and 3' by this number of nt [$addWidth]" >&2
  echo " -c <int>    minimal observation count to report in VCF file [$minObsCount]" >&2
  echo " -q <char>   filter out nucleotides below specified quality score character [$minQualFilter]" >&2
  echo " -G <file>   read gene and exon definitions from this file [none]" >&2
  echo " -T <dir>    read tromer transcript definitions from files in this directory [none]" >&2
  echo " -W          output coverage information in a wiggle file for each chromosome [none]" >&2
  echo " -A <file>   VCF input file containing annotated variants, used to annotate and concatenate VCFs generated by the caller [none]" >&2
  echo " -U <file>   JSON config file for realignmnt, triggered once provided" >&2
  echo " -n <dir>    Number of threads for realignment [$threads]">&2
  echo " -N <dir>    Temporary path [$tempdir]">&2
  echo " -l <int>    loop sorting process up to this number of time to try to fix killed sorting processes issues">&2
  echo "             (0 means disabled, -1 means keep trying while progress is observed) [$loop]">&2
  echo " -u <int>    reads have UMI of the specified length encoded in their headers (0 means disabled) [$UMI]">&2
  exit 1
}

while getopts ":s:d:hr:t:SCDm:b:w:c:q:G:T:WA:U:n:N:l:u:" opt; do
  case $opt in
    s)
      srcdir=$OPTARG
      ;;
    d)
      destdir=$OPTARG
      ;;
    h)
      usage
      ;;
    r)
      ref=$OPTARG
      ;;
    S)
      doSort=0
      ;;
    C)
      doCall=0
      ;;
    D)
      eraseInput=1
      ;;
    b)
      bedSelect=$OPTARG
      ;;
    m)
      minPct=$OPTARG
      ;;
    t)
      tables=$OPTARG
      ;;
    c)
      minObsCount=$OPTARG
      ;;
    q)
      minQualFilter=$OPTARG
      ;;
    G)
      GFFfile=$OPTARG
      ;;
    T)
      TromerFile=$OPTARG
      ;;
    w)
      addWidth=$OPTARG
      ;;
    W)
      doWiggle=1
      ;;
    A)
      annotVCFfile=$OPTARG
      ;;
    U)
      alignconfig=$OPTARG
      ;;
    n)
      threads=$OPTARG
      ;;
    N)
      tempdir=$OPTARG
      ;;
    l)
      loop=$OPTARG
      ;;
    u)
      UMI=$OPTARG
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      usage
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      usage
      ;;
  esac
done

if (( $# - $OPTIND != 0 )); then
  usage
fi
shift $(($OPTIND - 1))
name=$1
chrMax=`cut -f 1 $tables/$ref/$ref.cfg | sort -nr | head -1`
if [[ "X$chrMax" = "X" ]] ; then
  echo "Couldn't determine chrMax value" >&2
  exit 1
fi

if [[ "X$name" = "X" ]] ; then
  usage
fi
if [[ $doSort -ne 0 ]] ; then
  nbSocket=`lscpu | grep ^Socket | sed 's/^.*:  *//'`
  nbCores=`lscpu | grep ^Core | sed 's/^.*:  *//'`
  nbCPU=$(( nbSocket * nbCores ))
  memRegions=`numactl -s | grep membind | sed 's/^membind: *//' | wc -w`
  memTotalkB=`cat /proc/meminfo | grep ^MemTotal | awk '{print $2}'`
  while true ; do
    [ -d $destdir/${name} ] || mkdir -p $destdir/${name} || exit 1
    for (( i = 0 ; i < memRegions ; i += 1 )) ; do
      memAvail[$i]=$(( memTotalkB / memRegions ))
    done
    running=0
    for (( i = 0 ; i < nbCPU ; i += 1 )) ; do
      r[$i]=0
      m[$i]=0
    done
    if ls $srcdir/${name}_?_UM_A.gtl >/dev/null 2>&1 ; then
      list=`ls $srcdir/${name}_?_UM_?.gtl | sed "s+$srcdir/${name}_.+$srcdir/${name}_A+" | sort -u`
      for f in $list; do
        s=`stat -c %s ${f/_A_UM_/_[A-Z]_UM_}`
        o=`echo $s | sed 's/[1-9][0-9]*/+/g;s/+$/p/'`
        s=`echo "$s $o" | dc`
        if [[ "X$minUMsize" = "X" || $s -lt $minUMsize ]] ; then
	  minUMsize=$s
        fi
      done
    else
      list=`ls $srcdir/${name}_?_UM_??.gtl | sed "s+$srcdir/${name}_.+$srcdir/${name}_A+" | sort -u`
      for f in $list; do
        s=`stat -c %s ${f/_A_UM_/_[A-Z]_UM_}`
        o=`echo $s | sed 's/[1-9][0-9]*/+/g;s/+$/p/'`
        s=`echo "$s $o" | dc`
        if [[ "X$minUMsize" = "X" || $s -lt $minUMsize ]] ; then
	  minUMsize=$s
        fi
      done
    fi
    list=`ls $srcdir/${name}_?_*.gtl | sed "s+$srcdir/${name}_.+$srcdir/${name}_A+" | sort -u`
    for f in $list; do
      mult=""
      files=""
      chr=`basename $f .gtl | sed "s/^${name}_A_\(chr\|C\|M\|HM\|UM\)/\1/"`
      case $chr in
        C_chr*)
	  if [[ -s $destdir/${name}/$chr.gtl ]] ; then
	    echo "$destdir/${name}/${chr}.gtl already exists : skipping $chr"
	    continue
	  fi
	  c=`echo $chr | sed 's/^C_chr//'`
	  c=$(( (c << 16) | 57 ))
	  files=`echo ${f/_A_C_chr/_[A-Z]_C_chr}`
	  s=`stat -c %s $files`
	  o=`echo $s | sed 's/[1-9][0-9]*/+/g;s/+$/2 * p/'`
	  # double size for chimeras
	  size=`echo "$s $o" | dc`
	  ;;
        C_d*)
	  if [[ -s $destdir/${name}/$chr.gtl ]] ; then
	    echo "$destdir/${name}/${chr}.gtl already exists : skipping $chr"
	    continue
	  fi
	  c=`echo $chr | sed 's/^C_d//'`
	  c=$(( ( (c + chrMax) << 16) | 57 ))
	  files=`echo ${f/_A_C_d/_[A-Z]_C_d}`
	  s=`stat -c %s $files`
	  o=`echo $s | sed 's/[1-9][0-9]*/+/g;s/+$/2 * p/'`
	  # double size for chimeras
	  size=`echo "$s $o" | dc`
	  ;;
        HM_chr*)
	  if [[ -s $destdir/${name}/$chr.gtl ]] ; then
	    echo "$destdir/${name}/${chr}.gtl already exists : skipping $chr"
	    continue
	  fi
	  c=`echo $chr | sed 's/^HM_chr//'`
	  c=$(( (c << 16) | 50 ))
	  files=`echo ${f/_A_HM_chr/_[A-Z]_HM_chr}`
	  s=`stat -c %s $files`
	  o=`echo $s | sed 's/[1-9][0-9]*/+/g;s/+$/p/'`
	  size=`echo "$s $o" | dc`
	  ;;
        UM_?|UM_??)
	  if [[ -s $destdir/${name}/$chr.gtl ]] ; then
	    echo "$destdir/${name}/${chr}.gtl already exists : skipping $chr"
	    continue
	  fi
	  files=`echo ${f/_A_UM_/_[A-Z]_UM_}`
	  c=`echo $chr | sed 's/^UM_//'`
	  case $c in
	    A|AA) c=0 ;;
	    C|AC) c=$(( 1 << 16)) ;;
	    G|AG) c=$(( 2 << 16)) ;;
	    T|AT) c=$(( 3 << 16)) ;;
	    CA) c=$(( 4 << 16)) ;;
	    CC) c=$(( 5 << 16)) ;;
	    CG) c=$(( 6 << 16)) ;;
	    CT) c=$(( 7 << 16)) ;;
	    GA) c=$(( 8 << 16)) ;;
	    GC) c=$(( 9 << 16)) ;;
	    GG) c=$(( 10 << 16)) ;;
	    GT) c=$(( 11 << 16)) ;;
	    TA) c=$(( 12 << 16)) ;;
	    TC) c=$(( 13 << 16)) ;;
	    TG) c=$(( 14 << 16)) ;;
	    TT) c=$(( 15 << 16)) ;;
	  esac
	  size=$minUMsize
	  ;;
        M_chr*)
	  if [[ -s $destdir/${name}/${chr}_p.gtl || -s $destdir/${name}/${chr}_N.gtl || -s $destdir/${name}/${chr}_m.gtl || -s $destdir/${name}/${chr}_g.gtl ]] ; then
	    echo "$destdir/${name}/${chr}_[pNmg].gtl already exists : skipping $chr"
	    continue
	  fi
	  c=`echo $chr | sed 's/^M_chr//;s/[abcd]$//'`
	  files=`echo ${f/_A_M_chr/_[A-Z]_M_chr}`
	  s=`stat -c %s $files`
	  o=`echo $s | sed 's/[1-9][0-9]*/+/g;s/+$/p/'`
	  size=`echo "$s $o" | dc`
	  mult=" -M"
	  ;;
        chr*)
	  if [[ -s $destdir/${name}/${chr}_p.gtl || -s $destdir/${name}/${chr}_N.gtl || -s $destdir/${name}/${chr}_m.gtl || -s $destdir/${name}/${chr}_g.gtl ]] ; then
	    echo "$destdir/${name}/${chr}_[pNmg].gtl already exists : skipping $chr"
	    continue
	  fi
	  c=`echo $chr | sed 's/^chr//;s/[abcd]$//'`
	  files=`echo ${f/_A_chr/_[A-Z]_chr}`
	  s=`stat -c %s $files`
	  o=`echo $s | sed 's/[1-9][0-9]*/+/g;s/+$/p/'`
	  size=`echo "$s $o" | dc`
	  ;;
      esac
      if [[ $nbCPU -gt 1 ]]; then
	# see how much kB are needed to process this file.  We assume ratio times size of file
	size=$(( size / 1024 * ratio ))
	myCPU=$nbCPU
	# see if we have a free CPU and enough memory
	while [[ $myCPU -eq $nbCPU ]] ; do
	  runlist=`jobs -l | grep Running | awk '{print $2}'`
	  if [[ "X$runlist" == "X" ]] ; then
	    running=0
	    myCPU=0
	    for (( i = 0 ; i < $nbCPU ; i += 1 )) ; do
	      if [[ ${r[$i]} -ne 0 ]] ; then
		memSlot=$(( i / (nbCPU / memRegions) ))
		(( memAvail[memSlot] += m[i] ))
		echo; echo "job ${r[$i]} in slot $i is done; freeing ${m[$i]} kB RAM to ${memAvail[$memSlot]}"
		r[$i]=0
		m[$i]=0
	      fi
	    done
	    break
	  fi
	  for (( i = 0 ; i < nbCPU ; i += 1 )) ; do
	    s[$i]=0
	  done
	  seen=0
	  for j in $runlist; do
	    for (( i = 0 ; i < $nbCPU ; i += 1 )) ; do
	      if [[ ${r[$i]} -eq $j ]] ; then
		#echo "job $j in slot $i is still running"
		s[$i]=1
		(( seen += 1 ))
		break
	      fi
	    done
	  done
	  if [[ $seen -eq $nbCPU ]] ; then
	    sleep 2
	    continue
	  fi
	  for (( i = 0 ; i < $nbCPU ; i += 1 )) ; do
	    if [[ ${s[$i]} -eq 0 && ${r[$i]} -ne 0 ]] ; then
	      memSlot=$(( i / (nbCPU / memRegions) ))
	      (( memAvail[memSlot] += m[i] ))
	      echo; echo "job ${r[$i]} in slot $i is done; freeing ${m[$i]} kB RAM to ${memAvail[$memSlot]}"
	      r[$i]=0
	      m[$i]=0
	      (( running -= 1 ))
	    fi
	  done
	  # determine if a memory region has enough space and a free slot
	  for (( i = 0 ; i < nbCPU ; i += 1 )) ; do
	    memSlot=$(( i / (nbCPU / memRegions) ))
	    if [[ ${memAvail[$memSlot]} -lt $size ]] ; then
	      continue
	    fi
	    if [[ ${r[$i]} -eq 0 ]] ; then
	      myCPU=$i
	      echo; echo "selecting slot $i for $size < ${memAvail[$memSlot]}"
	      break
	    fi
	  done
	  # sleep a few seconds if we have not found a slot
	  if [[ $myCPU -eq $nbCPU ]] ; then
	    sleep 2
	  fi
	done
	if [[ ${r[$myCPU]} -eq 0 ]] ; then
	  memSlot=$(( myCPU / (nbCPU / memRegions) ))
	  u=
	  if [[ $UMI -gt 0 ]]; then u="-u $UMI"; fi
	  numactl --physcpubind=$myCPU --membind=$memSlot $BINDIR/GTLsimpleSort $u -m $chrMax -z zip -s zip -r <(cat $files) -c $c$mult -o $destdir/${name} &
	  r[$myCPU]=$!
	  m[$myCPU]=$size
	  (( memAvail[memSlot] -= m[myCPU] ))
	  echo "Started $f in slot $myCPU as ${r[$myCPU]} physCPU=$myCPU memRegion=$memSlot size=$size kB ; remains ${memAvail[$memSlot]}"
	  (( running += 1 ))
	else
	  echo "HWHAP: $myCPU should be an empty slot..."
	  exit 1
	fi
      else
	echo "Sorting $f"
	$BINDIR/GTLsimpleSort $u -m $chrMax -z zip -s zip -r <(cat $files) -c $c$mult -o $destdir/${name}
      fi
    done
    wait
    totalIn=0
    totalOut=0
    failure=0
    list=`ls $srcdir/${name}_?_*.gtl | sed "s+$srcdir/${name}_.+$srcdir/${name}_A+" | sort -u`
    for f in $list; do
      files=""
      chr=`basename $f .gtl | sed "s/^${name}_A_\(chr\|C\|M\|HM\|UM\)/\1/"`
      case $chr in
        C_chr*)
	  if [[ -s $destdir/${name}/$chr.gtl ]] ; then
	    outcnt=`$BINDIR/GTLcnt -r $destdir/${name}/$chr.gtl`
	  else
	    outcnt=0
	  fi
	  files=`echo ${f/_A_C_chr/_[A-Z]_C_chr}`
	  incnt=`$BINDIR/GTLcnt -r <(cat $files)`
	  if [[ $incnt -ne $outcnt ]] ; then
	    echo "Error in $chr : $incnt -ne $outcnt"
	    echo "  in : $files"
	    echo "  out : $destdir/${name}/$chr.gtl"
	    failure=$((failure + 1))
	    if [[ $loop -ne 0 ]]; then
	      echo "=> removing $destdir/${name}/$chr.gtl"
	      rm -f $destdir/${name}/$chr.gtl
	    fi
	  fi
	  totalIn=$((totalIn + incnt))
	  totalOut=$((totalOut + outcnt))
	  ;;
        C_d*)
	  if [[ -s $destdir/${name}/$chr.gtl ]] ; then
	    outcnt=`$BINDIR/GTLcnt -r $destdir/${name}/$chr.gtl`
	  else
	    outcnt=0
	  fi
	  files=`echo ${f/_A_C_d/_[A-Z]_C_d}`
	  incnt=`$BINDIR/GTLcnt -r <(cat $files)`
	  if [[ $incnt -ne $outcnt ]] ; then
	    echo "Error in $chr : $incnt -ne $outcnt"
	    echo "  in : $files"
	    echo "  out : $destdir/${name}/$chr.gtl"
	    failure=$((failure + 1))
	    if [[ $loop -ne 0 ]]; then
	      echo "=> removing $destdir/${name}/$chr.gtl"
	      rm -f $destdir/${name}/$chr.gtl
	    fi
	  fi
	  totalIn=$((totalIn + incnt))
	  totalOut=$((totalOut + outcnt))
	  ;;
        HM_chr*)
	  if [[ -s $destdir/${name}/$chr.gtl ]] ; then
	    outcnt=`$BINDIR/GTLcnt -r $destdir/${name}/$chr.gtl`
	  else
	    outcnt=0
	  fi
	  files=`echo ${f/_A_HM_chr/_[A-Z]_HM_chr}`
	  incnt=`$BINDIR/GTLcnt -r <(cat $files)`
	  if [[ $incnt -ne $outcnt ]] ; then
	    echo "Error in $chr : $incnt -ne $outcnt"
	    echo "  in : $files"
	    echo "  out : $destdir/${name}/$chr.gtl"
	    failure=$((failure + 1))
	    if [[ $loop -ne 0 ]]; then
	      echo "=> removing $destdir/${name}/$chr.gtl"
	      rm -f $destdir/${name}/$chr.gtl
	    fi
	  fi
	  totalIn=$((totalIn + incnt))
	  totalOut=$((totalOut + outcnt))
	  ;;
        UM_?|UM_??)
	  if [[ -s $destdir/${name}/$chr.gtl ]] ; then
	    outcnt=`$BINDIR/GTLcnt -r <(cat $destdir/${name}/$chr*.gtl)`
	  else
	    outcnt=0
	  fi
	  files=`echo ${f/_A_UM_/_[A-Z]_UM_}`
	  incnt=`$BINDIR/GTLcnt -r <(cat $files)`
	  if [[ $incnt -ne $outcnt ]] ; then
	    echo "Error in $chr : $incnt -ne $outcnt"
	    echo "  in : $files"
	    echo "  out : $destdir/${name}/$chr*.gtl"
	    failure=$((failure + 1))
	    if [[ $loop -ne 0 ]]; then
	      echo "=> removing $destdir/${name}/$chr*.gtl"
	      rm -f $destdir/${name}/$chr*.gtl
	    fi
	  fi
	  totalIn=$((totalIn + incnt))
	  totalOut=$((totalOut + outcnt))
	  ;;
        M_chr*)
	  if [[ -s $destdir/${name}/${chr}_p.gtl || -s $destdir/${name}/${chr}_N.gtl || -s $destdir/${name}/${chr}_m.gtl || -s $destdir/${name}/${chr}_g.gtl ]] ; then
	    outcnt=`$BINDIR/GTLcnt -r <(cat $destdir/${name}/$chr*.gtl)`
	  else
	    outcnt=0
	  fi
	  files=`echo ${f/_A_M_chr/_[A-Z]_M_chr}`
	  incnt=`$BINDIR/GTLcnt -r <(cat $files)`
	  if [[ $incnt -ne $outcnt ]] ; then
	    echo "Error in $chr : $incnt -ne $outcnt"
	    echo "  in : $files"
	    echo "  out : $destdir/${name}/$chr*.gtl"
	    failure=$((failure + 1))
	    if [[ $loop -ne 0 ]]; then
	      echo "=> removing $destdir/${name}/$chr*.gtl"
	      rm -f $destdir/${name}/$chr*.gtl
	    fi
	  fi
	  totalIn=$((totalIn + incnt))
	  totalOut=$((totalOut + outcnt))
	  ;;
        chr*)
	  if [[ -s $destdir/${name}/${chr}_p.gtl || -s $destdir/${name}/${chr}_N.gtl || -s $destdir/${name}/${chr}_m.gtl || -s $destdir/${name}/${chr}_g.gtl ]] ; then
	    outcnt=`$BINDIR/GTLcnt -r <(cat $destdir/${name}/$chr*.gtl)`
	  else
	    outcnt=0
	  fi
	  files=`echo ${f/_A_chr/_[A-Z]_chr}`
	  incnt=`$BINDIR/GTLcnt -r <(cat $files)`
	  if [[ $incnt -ne $outcnt ]] ; then
	    echo "Error in $chr : $incnt -ne $outcnt"
	    echo "  in : $files"
	    echo "  out : $destdir/${name}/$chr*.gtl"
	    failure=$((failure + 1))
	    if [[ $loop -ne 0 ]]; then
	      echo "=> removing $destdir/${name}/$chr*.gtl"
	      rm -f $destdir/${name}/$chr*.gtl
	    fi
	  fi
	  totalIn=$((totalIn + incnt))
	  totalOut=$((totalOut + outcnt))
	  ;;
      esac
    done
    if [[ $totalIn -eq 0 ]] ; then
      echo -e "\e[1;31mThe total number of input is 0, something seems wrong\e[0m"
      exit 1
    fi
    if [[ $failure -eq 0 ]] ; then
      echo -e "\e[1;32mSeems counts match - $totalIn == $totalOut \e[33m:-)\e[0m"
      break
    else
      if [[ $loop -eq -1 ]]; then
	if [[ $failure -eq $lastFailure ]] ; then
	  if [[ $failure -eq $lastFailure && $nbCPU -gt 1 ]] ; then
	    echo -e "\e[1;33mWe still counted $failure, as before - retrying with only 1 thread\e[0m"
	    nbCPU=1
	    memRegions=1
	    memAvail[0]=$memTotalkB
	  else
	    echo -e "\e[1;31mWe counted $failure failures and we already had $lastFailure failures :-(\e[0m"
	    exit 1
	  fi
	else
	  echo -e "\e[1;33mWe counted $failure failures and had $lastFailure failures before - retrying\e[0m"
	  lastFailure=$failure
	fi
      else
	if [[ $loop -gt 0 ]]; then
	  echo -e "\e[1;33mWe counted $failure failures - $loop more retry\e[0m"
	  loop=$(( loop - 1 ))
	else
	  echo -e "\e[1;31mWe counted $failure failures and exhausted repeat count :-(\e[0m"
	  exit 1
	fi
      fi
    fi
  done
  if [[ $eraseInput -ne 0 ]] ; then
    rm $srcdir/${name}_*.gtl
  fi
fi
if [[ $doCall -ne 0 ]] ; then
  for i in `seq 1 $chrMax`; do
    echo "$i"
    callerArg="-a -m $minPct"
    if [[ "X$bedSelect" != "X" ]] ; then
      callerArg="$callerArg -s $bedSelect -w $addWidth"
    fi
    if [[ $doWiggle -ne 0 ]] ; then
      callerArg="$callerArg -b $destdir/${name}/chr$i.bed"
    fi
    if [[ "X$GFFfile" != "X" || "X$TromerFile" != "X" ]]; then
      callerArg="$callerArg -e $destdir/${name}/chr${i}_gene.txt"
      if [[ "X$GFFfile" != "X" ]]; then
	callerArg="$callerArg -G $GFFfile"
      fi
      if [[ "X$TromerFile" != "X" ]]; then
	callerArg="$callerArg -t $TromerFile"
      fi
    fi
    if [[ "X$alignconfig" != "X" ]] ; then
      callerArg="$callerArg -R $alignconfig -T $threads"
    fi
    if [[ $verbose -gt 0 ]]; then
      echo "$BINDIR/GTLcaller $callerArg \
	-f $minQualFilter \
	-g $tables/$ref/$ref.bin \
	-C $i \
	-r <(cat $destdir/${name}/chr$i[abcd]_?.gtl) \
	-V $minObsCount \
	-N $name \
	>$tempdir/${name}_chr$i.vcf \
	2>$destdir/${name}/chr$i.ref"
    fi
    $BINDIR/GTLcaller $callerArg \
      -f $minQualFilter \
      -g $tables/$ref/$ref.bin \
      -C $i \
      -r <(cat $destdir/${name}/chr$i[abcd]_?.gtl) \
      -V $minObsCount \
      -N $name \
      >$tempdir/${name}_chr$i.vcf \
      2>$destdir/${name}/chr$i.ref
  done
  if [[ "X$annotVCFfile" != "X" ]] ; then
    $BINDIR/annotateVCF -SNP $annotVCFfile $tempdir/${name}_chr?.vcf $tempdir/${name}_chr??.vcf >$destdir/${name}.vcf
    if [[ $eraseInput -ne 0 ]] ; then
      rm $tempdir/${name}_chr{?,??}.vcf
    fi
  fi
fi
exit 0
